# leetcode

## 一、DFS
1. 判断树是否是满足某种关系(true or false)，如是否是搜索树、是否对称,一般使用前中后序遍历可解决问题


[验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)

[相同的树](https://leetcode-cn.com/problems/same-tree/)

[对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)

2. 寻找树中的某种参数，如树的深度、某种组合等

[二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

[平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/)

[二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)

[路径总和](https://leetcode-cn.com/problems/path-sum/)

[路径总和2](https://leetcode-cn.com/problems/path-sum-ii/)

3. 利用二叉树、遍历的某种性质解决问题,如根据便利结果构造二叉树

> note:前序遍历的结果中，第一个元素是根节点的值，后面依次是左子树和右子树，每一个子树都符合这种结构；对于中序和后续遍历，唯一的不同是根节点位于中间和最后

> 前序遍历：[root node,(left subtree),(right subtree)]

> 中序遍历：[(left subtree),root node,(right subtree)]

> 后序遍历：[(left subtree),(right subtree),root node]

[从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

[从中序与后序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

[将有序数组转换为二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/)

[二叉树展开为链表](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/)

## 二、BFS

[填充每个节点的下一个右侧节点指针](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/)

